<?php

declare(strict_types=1);

/**
 * This file is part of the MultiFlexi package
 *
 * https://multiflexi.eu/
 *
 * (c) Vítězslav Dvořák <http://vitexsoftware.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * This is an example of using OAuth2 Application Flow in a specification to describe security to your API.
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git.
 */
/**
 * NOTE: This class is auto generated by the openapi generator program.
 * https://github.com/openapitools/openapi-generator.
 */
require_once __DIR__.'/../../vendor/autoload.php';

use DI\Bridge\Slim\Bridge;
use DI\ContainerBuilder;
use MultiFlexi\Api\App\RegisterDependencies;
use MultiFlexi\Api\App\RegisterMiddlewares;
use MultiFlexi\Api\App\RegisterRoutes;
use MultiFlexi\Api\App\ResponseEmitter as Response;
use Neomerx\Cors\Contracts\AnalyzerInterface;
use Slim\Factory\ServerRequestCreatorFactory;
use Slim\Middleware\ErrorMiddleware;

\Ease\Shared::singleton()->loadConfig(\dirname(__DIR__).'/../.env', true);

// Initialize API rate limiter
if (\Ease\Shared::cfg('API_RATE_LIMITING_ENABLED', true)) {
    try {
        $dsn = \Ease\Shared::cfg('DB_CONNECTION').':host='.\Ease\Shared::cfg('DB_HOST').';port='.\Ease\Shared::cfg('DB_PORT', 3306).';dbname='.\Ease\Shared::cfg('DB_DATABASE').';charset=utf8mb4';
        $pdo = new \PDO(
            $dsn,
            \Ease\Shared::cfg('DB_USERNAME'),
            \Ease\Shared::cfg('DB_PASSWORD'),
            [\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION],
        );
        $endpointLimits = [
            '/api/auth*' => ['limit' => 10, 'window' => 300], // 10 requests per 5 minutes for auth
            '/api/export*' => ['limit' => 5, 'window' => 3600], // 5 requests per hour for data export
            '/api/*' => ['limit' => \Ease\Shared::cfg('API_RATE_LIMIT_REQUESTS', 100), 'window' => \Ease\Shared::cfg('API_RATE_LIMIT_WINDOW', 3600)],
        ];

        $rateLimiter = new \MultiFlexi\Security\ApiRateLimiter($pdo, 100, 3600, $endpointLimits);

        if (!$rateLimiter->middleware()) {
            // Rate limit exceeded - response already sent by middleware
            exit;
        }
    } catch (\Exception $e) {
        // Log error but don't break the application
        error_log('Failed to initialize API rate limiter: '.$e->getMessage());
    }
}

// Instantiate PHP-DI ContainerBuilder
$builder = new ContainerBuilder();

// Main configuration
$builder->addDefinitions(__DIR__.'/config.php');

// Config file for the environment if exists
$userConfig = __DIR__.'/config.php';

if (file_exists($userConfig)) {
    $builder->addDefinitions($userConfig);
}

// Set up dependencies
$dependencies = new RegisterDependencies();
$dependencies($builder);

// Build PHP-DI Container instance
$container = $builder->build();

// Instantiate the app
$app = Bridge::create($container);

$uriParts = explode('/api/', \Ease\WebPage::getUri());
$basePath = $uriParts[0].'/api';

$app->setBasePath($basePath);
$path = $basePath.'/VitexSoftware/MultiFlexi/1.0.0/';

// Register middleware
$middleware = new RegisterMiddlewares();
$middleware($app);

// Register routes
// yes, it's anti-pattern you shouldn't get deps from container directly
$routes = $container->get(RegisterRoutes::class);
$routes($app);

// Create Request object from globals
$serverRequestCreator = ServerRequestCreatorFactory::create();
$request = $serverRequestCreator->createServerRequestFromGlobals();

// Get error middleware from container
// also anti-pattern, of course we know
$errorMiddleware = $container->get(ErrorMiddleware::class);

// Add custom error handler to convert 405 to 404 for non-existent paths
$errorMiddleware->setErrorHandler(
    \Slim\Exception\HttpMethodNotAllowedException::class,
    function (\Psr\Http\Message\ServerRequestInterface $request, \Throwable $exception, bool $displayErrorDetails) {
        $response = new \Slim\Psr7\Response();
        
        // Detect format suffix from URL
        $uri = $request->getUri()->getPath();
        $suffix = 'json'; // default
        if (preg_match('/\.(json|xml|html)$/', $uri, $matches)) {
            $suffix = $matches[1];
        }
        
        // Generate response based on suffix
        switch ($suffix) {
            case 'html':
                $content = '<!DOCTYPE html><html><head><title>404 Not Found</title></head><body><h1>Not Found</h1><p>The requested resource does not exist.</p><p><a href="javascript:history.back()">Go Back</a></p></body></html>';
                $contentType = 'text/html';
                break;
            case 'xml':
                $content = '<?xml version="1.0" encoding="UTF-8"?><error><code>404</code><message>The requested resource does not exist</message></error>';
                $contentType = 'application/xml';
                break;
            case 'json':
            default:
                $content = json_encode([
                    'error' => 'Not Found',
                    'message' => 'The requested resource does not exist',
                ]);
                $contentType = 'application/json';
                break;
        }
        
        $response->getBody()->write($content);
        return $response->withStatus(404)->withHeader('Content-Type', $contentType);
    }
);

// route0 → (unnamed) → /{routes:.*}
// route1 → listServers → /VitexSoftware/MultiFlexi/1.0.0/servers/
// route2 → setAbraFlexiById → /VitexSoftware/MultiFlexi/1.0.0/abraflexi/
// route3 → getAbraFlexiById → /VitexSoftware/MultiFlexi/1.0.0/abraflexi/{abraflexiId}
// route4 → listApps → /VitexSoftware/MultiFlexi/1.0.0/apps/
// route5 → setAppById → /VitexSoftware/MultiFlexi/1.0.0/app/
// route6 → getAppById → /VitexSoftware/MultiFlexi/1.0.0/app/{appId}
// route7 → getApiIndex → /VitexSoftware/MultiFlexi/1.0.0/
// route8 → loginGet → /VitexSoftware/MultiFlexi/1.0.0/login
// route9 → loginPost → /VitexSoftware/MultiFlexi/1.0.0/login
// route10 → pingGet → /VitexSoftware/MultiFlexi/1.0.0/ping
// route11 → (unnamed) → /

// Temporarily disable token authentication to test basic auth
// $app->add(new \Dyorg\TokenAuthentication([
//     'path' => $app->getBasePath(),
//     'passthrough' => [$path, $path.'ping', $path.'login'], /* Full paths to match basic auth ignore */
//     'authenticator' => static function ($arguments) {
//         // Check if token exists in database and is valid
//         $token = new \MultiFlexi\Token();
//         $token->loadFromSQL(['token' => $arguments['token']]);
//         return $token->getMyKey() !== null;
//     },
// ]));

$app->add(new \Tuupola\Middleware\HttpBasicAuthentication([
    'relaxed' => ['localhost', 'multiflexi.local'],
    //            'path' => ['/EASE/MultiFlexi/src/api/VitexSoftware/MultiFlexi/1.0.0/apps/', $path . '/apps', $path . '/users'],
    //            "ignore" => [$path . '/', $path . '/ping', $path . '/authorize'],
    //            'path' => '/',
    'ignore' => [$path, $path.'ping', $path.'login'],
    //            "authenticator" => new \MultiFlexi\Auth\BasicAuthenticator()
    'authenticator' => static function ($arguments) {
        $prober = \Ease\Shared::user(null, '\MultiFlexi\User');

        if ($prober->isLogged()) {
            return true;
        }

        $prober->loadFromSQL(['login' => $arguments['user']]);

        return $prober->isAccountEnabled() && $prober->passwordValidation($arguments['password'], $prober->getDataValue($prober->passwordColumn));
    },
]));

$app->get($basePath, static function (Request $request, Response $response, $args) {
    $response->getBody()->write('MultiFlexi Api Root');

    return $response;
});
session_start();
// Run App & Emit Response
$response = $app->handle($request);
$responseEmitter = (new Response())
    ->setRequest($request)
    ->setErrorMiddleware($errorMiddleware)
    ->setAnalyzer($container->get(AnalyzerInterface::class));

$responseEmitter->emit($response);
